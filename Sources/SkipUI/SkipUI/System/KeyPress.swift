// This is free software: you can redistribute and/or modify it
// under the terms of the GNU Lesser General Public License 3.0
// as published by the Free Software Foundation https://fsf.org

// TODO: Process for use in SkipUI

#if !SKIP

import struct Foundation.CharacterSet

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
public struct KeyPress : Sendable {

    /// The phase of the key-press event (`.down`, `.repeat`, or `.up`).
    public let phase: KeyPress.Phases = { fatalError() }()

    /// The key equivalent value for the pressed key.
    public let key: KeyEquivalent = { fatalError() }()

    /// The characters generated by the pressed key as if no modifier
    /// key applies.
    public let characters: String = { fatalError() }()

    /// The set of modifier keys the user held in addition to the
    /// pressed key.
    public let modifiers: EventModifiers = { fatalError() }()
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension KeyPress : CustomDebugStringConvertible {

    /// Options for matching different phases of a key-press event.
    public struct Phases : OptionSet, Sendable, CustomDebugStringConvertible {

        /// The user pressed down on a key.
        public static let down: KeyPress.Phases = { fatalError() }()

        /// The user held a key down to issue a sequence of repeating events.
        public static let `repeat`: KeyPress.Phases = { fatalError() }()

        /// The user released a key.
        public static let up: KeyPress.Phases = { fatalError() }()

        /// A value that matches all key press phases.
        public static let all: KeyPress.Phases = { fatalError() }()

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get { fatalError() } }

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int = { fatalError() }()

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: Int) { fatalError() }

        /// The type of the elements of an array literal.
        public typealias ArrayLiteralElement = KeyPress.Phases

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        public typealias Element = KeyPress.Phases

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = Int
    }

    /// A result value returned from a key-press action that indicates whether
    /// the action consumed the event.
    public enum Result : Sendable {

        /// The action consumed the event, preventing dispatch from continuing.
        case handled

        /// The action ignored the event, allowing dispatch to continue.
        case ignored

        

    
        }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get { fatalError() } }
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension KeyPress.Result : Equatable {
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension KeyPress.Result : Hashable {
}

@available(iOS 17.0, macOS 14.0, tvOS 17.0, *)
@available(watchOS, unavailable)
extension View {

    /// Performs an action if the user presses a key on a hardware keyboard
    /// while the view has focus.
    ///
    /// SkipUI performs the action for key-down and key-repeat events.
    ///
    /// - Parameters:
    ///   - key: The key to match against incoming hardware keyboard events.
    ///   - action: The action to perform. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds hardware keyboard input
    ///   when focused.
    public func onKeyPress(_ key: KeyEquivalent, action: @escaping () -> KeyPress.Result) -> some View { return stubView() }


    /// Performs an action if the user presses a key on a hardware keyboard
    /// while the view has focus.
    ///
    /// SkipUI performs the action for the specified event phases.
    ///
    /// - Parameters:
    ///   - key: The key to match against incoming hardware keyboard events.
    ///   - phases: The key-press phases to match (`.down`, `.up`,
    ///     and `.repeat`).
    ///   - action: The action to perform. The action receives a value
    ///     describing the matched key event. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds hardware keyboard input
    ///   when focused.
    public func onKeyPress(_ key: KeyEquivalent, phases: KeyPress.Phases, action: @escaping (KeyPress) -> KeyPress.Result) -> some View { return stubView() }


    /// Performs an action if the user presses one or more keys on a hardware
    /// keyboard while the view has focus.
    ///
    /// - Parameters:
    ///   - keys: A set of keys to match against incoming hardware
    ///     keyboard events.
    ///   - phases: The key-press phases to match (`.down`, `.repeat`, and
    ///     `.up`). The default value is `[.down, .repeat]`.
    ///   - action: The action to perform. The action receives a value
    ///     describing the matched key event. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds keyboard input when focused.
    public func onKeyPress(keys: Set<KeyEquivalent>, phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> some View { return stubView() }


    /// Performs an action if the user presses one or more keys on a hardware
    /// keyboard while the view has focus.
    ///
    /// - Parameters:
    ///   - characters: The set of characters to match against incoming
    ///     hardware keyboard events.
    ///   - phases: The key-press phases to match (`.down`, `.repeat`, and
    ///     `.up`). The default value is `[.down, .repeat]`.
    ///   - action: The action to perform. The action receives a value
    ///     describing the matched key event. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds hardware keyboard input
    ///   when focused.
    public func onKeyPress(characters: CharacterSet, phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> some View { return stubView() }


    /// Performs an action if the user presses any key on a hardware keyboard
    /// while the view has focus.
    ///
    /// - Parameters:
    ///   - phases: The key-press phases to match (`.down`, `.repeat`, and
    ///     `.up`). The default value is `[.down, .repeat]`.
    ///   - action: The action to perform. The action receives a value
    ///     describing the matched key event. Return `.handled` to consume the
    ///     event and prevent further dispatch, or `.ignored` to allow dispatch
    ///     to continue.
    /// - Returns: A modified view that binds hardware keyboard input
    ///   when focused.
    public func onKeyPress(phases: KeyPress.Phases = [.down, .repeat], action: @escaping (KeyPress) -> KeyPress.Result) -> some View { return stubView() }

}


#endif
